devtools::document()
usethat::use_vignette("introduction")
install.packages("usethat")
devtools::use_vignette("introduction")
devtools::load_all()
devtools::install()
library(trapCatch)
library(lobsterCatch)
devtools::install_github("tinyheero/tinyutils", upgrade_dependencies = FALSE)
no
source("https://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
biocLite("Rsamtools")
source("https://bioconductor.org/biocLite.R")
install.packages("Bioconductor ")
biocLite("GenomicRanges")
source("https://bioconductor.org/biocLite.R")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install()
BiocManager::install()
biocLite("Rsamtools")
biocLite("GenomicRanges")
source("https://bioconductor.org/biocLite.R")
library("tinyutils")
ls("package:tinyutils")
plot_feature_sample_mat
devtools::install_github("vpourfaraj/lobsterCatch")
devtools::install_github("vpourfaraj/lobsterCatch")
devtools::install_github("vpourfaraj/lobsterCatchPackage")
?catchability
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
#Once the package is installed, data in extdata folder can be accessed using this code:
system.file("extdata", "LobsterSizeFreqs.csv", package = "lobsterCatch")
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$niter =100
#run the model
a = SimulateLobsterMovement(p=p)
library(lobsterCatch)
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$niter =100
#run the model
a = SimulateLobsterMovement(p=p)
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$niter =100
#run the model
a = SimulateLobsterMovement(p=p)
p$realizations=20
#run the model
a = SimulateLobsterMovement(p=p)
require(devtools)
require(geosphere)
?load_all
arena = matrix(0,12,12)
y=x=seq(1,11,2)
traps = expand.grid(x,y)
arena
y
traps
p = list()
p$nrowgrids = 12
p$ncolgrids = 12
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapEastStart = traps[,1]
p$trapNorthStart = traps[,2]
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = .1
p$dstepstart = 5
p$trapSaturationStart = T
p$tSteps = 50
p$realizations = 1
a = SimulateLobsterMovement(p=p)
#nLobsters
uL = unique(a[[1]]$lobsters$I)
uL
dims = length(uL)
dims
dims = ceiling(sqrt(dims))
par( mfrow=c(dims,dims) ) # create a plot with 1 row and 2 columns to show plots side by side
for(i in uL){
with(subset(a[[1]]$lobsters, I==1),plot(EASTING, NORTHING, type='l',ylim=c(-30,30),xlim=c(-30,30)))
points(traps, pch=16, col='red')
#with(subset(outmove, I==1), text(x=EASTING[c(1,100)], y=NORTHING[c(1,100)], c('Start','End')))
}
smm = seq(0.8,.99,by=0.02)
gg = list()
for(i in 1:length(smm)){
p$smult=smm[i]
a = SimulateLobsterMovement(p=p)
gg[[i]]=c(mean(apply(a[[1]]$traps,2,max)),dispersion(apply(a[[1]]$traps,2,max)))
}
#This function also needs to change in order to assign length to lobsters and keep track of trapped lobster's size
SimulateLobsterMovement <- function(p=p,plot=F) {
outputs.to.return = list()
#This function also needs to change in order to assign length to lobsters and keep track of trapped lobster's size
SimulateLobsterMovement <- function(p=p,plot=F) {
#This function also needs to change in order to assign length to lobsters and keep track of trapped lobster's size
SimulateLobsterMovement <- function(p=p,plot=F) {
SimulateLobsterMovement <- function(p=p,plot=F) {
with(p,{
outputs.to.return = list()
for(k in 1:p$realizations){
start = Sys.time()
outputs = list()
initialGrid = rpoisD(n=ngrids,lambda=initlambda, D = initD)
LobsterStart = data.frame(EASTING = rep(1:ncolgrids,times=nrowgrids), NORTHING = rep(1:nrowgrids,each=ncolgrids), Lobs = initialGrid)
LobsterStart <- subset(LobsterStart,Lobs>0)
if(nrow(LobsterStart)>0) {
replicateCoordinates <- function(d){ rep(d[1:2], d[3]) } #replicates coordinates for grids with more than 1 lobster
tt <- unlist( apply(X = LobsterStart, MARGIN = 1, FUN = replicateCoordinates) )
tt<- matrix(tt, ncol = 2, byrow = TRUE)
colnames(tt)<- c("EASTING","NORTHING")
initialxyCoordinate  = as.data.frame(tt)
initialxyCoordinate$trapped = 0 # this will update as a lobster gets caught and we don't need to update movements
coordinatesOverTime <- list()
coordinatesOverTime[[1]] <- initialxyCoordinate
currentZoI<- currentZoIInit
ntraps = ntrapsstart
trapCoordinates = data.frame(EASTING=trapEastStart,NORTHING=trapNorthStart)
trapCatch = list()
trapCatch[[1]] = rep(0,length=ntraps)
outputs$traps = rep(0,times=ntrapsstart)
outputs$lobsters = data.frame(EASTING=0,NORTHING=0,trapped=0,T=0,I=0)
for(t in 2:tSteps){
if(t>2) currentZoI<- currentZoI * smult
ko = updateGrid( lobsterCoordinates = coordinatesOverTime[[t-1]], trapCoordinates=trapCoordinates, trapCatch=trapCatch[[t-1]], currentZoI = currentZoI,saturationThreshold=saturationThresholdStart,trapSaturation= trapSaturationStart, how_close=how_closeStart,dstep=dstepstart)
coordinatesOverTime[[t]] <- ko[[1]]
trapCatch[[t]] <- ko[[2]]
}
}
outmove = do.call(rbind,coordinatesOverTime)
outmove$T = rep(0:(tSteps-1), each=nrow(tt))
outmove$I = rep(1:nrow(tt), times=tSteps)
outtraps = as.data.frame(do.call(rbind, trapCatch))
outputs$traps = outtraps
outputs$lobsters = outmove
outputs.to.return[[k]] = outputs
print(paste('Timing', Sys.time()-start, 'for iteration #',k,sep=" "))
}
return(outputs.to.return)
})}
#This function also needs to change in order to assign length to lobsters and keep track of trapped lobster's size
SimulateLobsterMovement <- function(p=p,plot=F) {
with(p,{
outputs.to.return = list()
for(k in 1:p$realizations){
start = Sys.time()
outputs = list()
initialGrid = rpoisD(n=ngrids,lambda=initlambda, D = initD)
LobsterStart = data.frame(EASTING = rep(1:ncolgrids,times=nrowgrids), NORTHING = rep(1:nrowgrids,each=ncolgrids), Lobs = initialGrid)
LobsterStart <- subset(LobsterStart,Lobs>0)
if(nrow(LobsterStart)>0) {
replicateCoordinates <- function(d){ rep(d[1:2], d[3]) } #replicates coordinates for grids with more than 1 lobster
tt <- unlist( apply(X = LobsterStart, MARGIN = 1, FUN = replicateCoordinates) )
tt<- matrix(tt, ncol = 2, byrow = TRUE)
colnames(tt)<- c("EASTING","NORTHING")
initialxyCoordinate  = as.data.frame(tt)
initialxyCoordinate$trapped = 0 # this will update as a lobster gets caught and we don't need to update movements
initialxyCoordinate$CL <- NA # Length of lobsters
#uses the distribution of lengths in the csv file and assigns a size bin to each lobster
lobsterSizeFreq <- read.csv(file = 'LobsterSizeFreqs.csv', header = TRUE, stringsAsFactors = FALSE)
lobsterSizeFreq$prob <- lobsterSizeFreq$freq / sum(lobsterSizeFreq$freq )
labels   <- lobsterSizeFreq$bins
lobProb <- lobsterSizeFreq$prob
initialxyCoordinate$CL<-sample(x = labels, size = sum(initialGrid), replace = TRUE, prob = lobProb)
coordinatesOverTime <- list()
coordinatesOverTime[[1]] <- initialxyCoordinate
currentZoI<- currentZoIInit
s =  smult
ntraps = ntrapsstart
trapCoordinates = data.frame(EASTING=trapEastStart,NORTHING=trapNorthStart)
trapCatch = list()
lobSize   = list() #added to store the size of caught lobster
trapCatch[[1]] = rep(0,length=ntraps)
lobSize[[1]]   = rep('',length=ntraps)
outputs$traps = rep(0,times=ntrapsstart)
outputs$lobsters = data.frame(EASTING=0,NORTHING=0,trapped=0,T=0,I=0)
for(t in 2:tSteps){
if(t>2) currentZoI<- currentZoI * smult
ko = updateGridLB( lobsterCoordinates = coordinatesOverTime[[t-1]], trapCoordinates=trapCoordinates, trapCatch=trapCatch[[t-1]], lobSize = lobSize[[t-1]], currentZoI = currentZoI, saturationThreshold=saturationThresholdStart, trapSaturation= trapSaturationStart, how_close=how_closeStart,dstep=dstepstart, lengthBased = lengthBased)
coordinatesOverTime[[t]] <- ko[[1]]
trapCatch[[t]] <- ko[[2]]
lobSize[[t]]   <- ko[[3]]
}
}
outmove = do.call(rbind,coordinatesOverTime)
outmove$T = rep(0:(tSteps-1), each=nrow(tt))
outmove$I = rep(1:nrow(tt), times=tSteps)
outtraps = as.data.frame(do.call(rbind, trapCatch))
outputs$traps = outtraps
outputs$lobsters = outmove
outputs$lobSize = lobSize #Not sure if this is working properly yet
outputs.to.return[[k]] = outputs
print(paste('Timing', Sys.time()-start, 'for iteration #',k,sep=" "))
}
return(outputs.to.return)
})}
#last update : 11 Feb
#updateGridLB is a modified version of updateGrid that keeps track of lobster size
updateGridLB    = function(lobsterCoordinates,trapCoordinates, trapCatch, lobSize, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T, lengthBased = F){
updateGrid    = function(lobsterCoordinates,trapCoordinates, trapCatch, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T){
numberOfLobsters <- nrow(lobsterCoordinates)
if(numberOfLobsters>0){
xNew <- vector(mode = 'numeric', length = numberOfLobsters)
yNew <- vector(mode = 'numeric', length = numberOfLobsters)
trappedLobster<- vector(mode = 'numeric', length = numberOfLobsters)
for( lobsterIndex in 1:numberOfLobsters ){
xOld <- lobsterCoordinates[lobsterIndex,1]
yOld <- lobsterCoordinates[lobsterIndex,2]
trapped <- lobsterCoordinates[lobsterIndex,3]
if(trapped==1){
xNew[lobsterIndex] = xOld
yNew[lobsterIndex] = yOld
trappedLobster[lobsterIndex] = trapped
next()
}
distanceToTrap = distanceClosestTrap(lob_loc = c(xOld,yOld), trap_loc = trapCoordinates[,c(1,2)] )
if( distanceToTrap[1] > radius_of_influence){
temp <- randomMove(xLobster = xOld , yLobster = yOld , dStep = dstep)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedLobster[lobsterIndex] = 0
}else{
temp <- directionalMove(xLobster = xOld , yLobster = yOld , distanceToTrap = distanceToTrap[1], radius_of_influence = radius_of_influence, dStep = dstep, ZoI = currentZoI)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedQ = trapInPath(loc1 = c(xOld,yOld), loc2 = c(xNew[lobsterIndex],yNew[lobsterIndex]), trap_loc = trapCoordinates[distanceToTrap[2],],how_close=how_close)
if(trappedQ[3]==1) {
if(trapSaturation) pC = catchability(q0= q0,qmin=qmin, saturationThreshold=saturationThreshold, Ct=trapCatch[distanceToTrap[2]] )
if(!trapSaturation) pC = q0
caught = rbinom(n=1,size=1,prob=pC)
if(caught==1){
trapCatch[distanceToTrap[2]] =trapCatch[distanceToTrap[2]]+1
xNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],1]
yNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],2]
trappedLobster[lobsterIndex] = 1
}
}
}
}
updatedGrid <- data.frame(EASTING = xNew, NORTHING = yNew, trapped = trappedLobster)
return(list(updatedGrid, trapCatch))
}
}
updateGrid    = function(lobsterCoordinates,trapCoordinates, trapCatch, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T){
numberOfLobsters <- nrow(lobsterCoordinates)
if(numberOfLobsters>0){
xNew <- vector(mode = 'numeric', length = numberOfLobsters)
yNew <- vector(mode = 'numeric', length = numberOfLobsters)
trappedLobster<- vector(mode = 'numeric', length = numberOfLobsters)
for( lobsterIndex in 1:numberOfLobsters ){
xOld <- lobsterCoordinates[lobsterIndex,1]
yOld <- lobsterCoordinates[lobsterIndex,2]
trapped <- lobsterCoordinates[lobsterIndex,3]
if(trapped==1){
xNew[lobsterIndex] = xOld
yNew[lobsterIndex] = yOld
trappedLobster[lobsterIndex] = trapped
next()
}
distanceToTrap = distanceClosestTrap(lob_loc = c(xOld,yOld), trap_loc = trapCoordinates[,c(1,2)] )
if( distanceToTrap[1] > radius_of_influence){
temp <- randomMove(xLobster = xOld , yLobster = yOld , dStep = dstep)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedLobster[lobsterIndex] = 0
}else{
temp <- directionalMove(xLobster = xOld , yLobster = yOld , distanceToTrap = distanceToTrap[1], radius_of_influence = radius_of_influence, dStep = dstep, ZoI = currentZoI)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedQ = trapInPath(loc1 = c(xOld,yOld), loc2 = c(xNew[lobsterIndex],yNew[lobsterIndex]), trap_loc = trapCoordinates[distanceToTrap[2],],how_close=how_close)
if(trappedQ[3]==1) {
if(trapSaturation) pC = catchability(q0= q0,qmin=qmin, saturationThreshold=saturationThreshold, Ct=trapCatch[distanceToTrap[2]] )
if(!trapSaturation) pC = q0
caught = rbinom(n=1,size=1,prob=pC)
if(caught==1){
trapCatch[distanceToTrap[2]] =trapCatch[distanceToTrap[2]]+1
xNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],1]
yNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],2]
trappedLobster[lobsterIndex] = 1
}
}
}
}
updatedGrid <- data.frame(EASTING = xNew, NORTHING = yNew, trapped = trappedLobster)
return(list(updatedGrid, trapCatch))
}
}
updateGrid    = function(lobsterCoordinates,trapCoordinates, trapCatch, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T){
numberOfLobsters <- nrow(lobsterCoordinates)
if(numberOfLobsters>0){
xNew <- vector(mode = 'numeric', length = numberOfLobsters)
yNew <- vector(mode = 'numeric', length = numberOfLobsters)
trappedLobster<- vector(mode = 'numeric', length = numberOfLobsters)
for( lobsterIndex in 1:numberOfLobsters ){
xOld <- lobsterCoordinates[lobsterIndex,1]
yOld <- lobsterCoordinates[lobsterIndex,2]
trapped <- lobsterCoordinates[lobsterIndex,3]
if(trapped==1){
xNew[lobsterIndex] = xOld
yNew[lobsterIndex] = yOld
trappedLobster[lobsterIndex] = trapped
next()
}
distanceToTrap = distanceClosestTrap(lob_loc = c(xOld,yOld), trap_loc = trapCoordinates[,c(1,2)] )
if( distanceToTrap[1] > radius_of_influence){
temp <- randomMove(xLobster = xOld , yLobster = yOld , dStep = dstep)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedLobster[lobsterIndex] = 0
}else{
temp <- directionalMove(xLobster = xOld , yLobster = yOld , distanceToTrap = distanceToTrap[1], radius_of_influence = radius_of_influence, dStep = dstep, ZoI = currentZoI)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedQ = trapInPath(loc1 = c(xOld,yOld), loc2 = c(xNew[lobsterIndex],yNew[lobsterIndex]), trap_loc = trapCoordinates[distanceToTrap[2],],how_close=how_close)
if(trappedQ[3]==1) {
if(trapSaturation) pC = catchability(q0= q0,qmin=qmin, saturationThreshold=saturationThreshold, Ct=trapCatch[distanceToTrap[2]] )
if(!trapSaturation) pC = q0
caught = rbinom(n=1,size=1,prob=pC)
if(caught==1){
trapCatch[distanceToTrap[2]] =trapCatch[distanceToTrap[2]]+1
xNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],1]
yNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],2]
trappedLobster[lobsterIndex] = 1
}
}
}
}
updatedGrid <- data.frame(EASTING = xNew, NORTHING = yNew, trapped = trappedLobster)
return(list(updatedGrid, trapCatch))
}
}
devtools::document()
getwd(
)
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
library(lobsterCatch)
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$realizations=5 #number of iterations/simulations
p$tSteps=10  #timesteps per iteration
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
#run the model
a = SimulateLobsterMovement(p=p)
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
library(lobsterCatch)
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$realizations=5 #number of iterations/simulations
p$tSteps=10  #timesteps per iteration
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='N Caught')
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='N Caught', ylim=(o,10))
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='N Caught', ylim=(0,10))
a[[1]]
View(a)
plot(1:p$realizations,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
plot(1:p$realizations,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
#lets change a parameter
p$saturationThresholdStart=10
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$niter,b$traps[,1])
lines(1:p$tSteps,b$traps[,1])
lines(1:p$tSteps,b$[[1]]$traps[,3])
lines(1:p$tSteps,b[[1]]$traps[,3])
#lets change a parameter
p$saturationThresholdStart=10
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,3])
#lets change a parameter
p$saturationThresholdStart=20
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,3])
b[[1]]
b[[1]]$traps[,3]
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
lines(1:p$tSteps,b[[1]]$traps[,3])
#run the model
a = SimulateLobsterMovement(p=p)
p$realizations=10 #number of iterations/simulations
p$tSteps=50  #timesteps per iteration
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught')
#lets change a parameter
p$saturationThresholdStart=20
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,2])
?plot
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught',ylim = c(o,10))
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
lines(1:p$tSteps,b[[1]]$traps[,2])
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,2])
lines(1:p$tSteps,b[[1]]$traps[,3])
b
p$lengthBased= FALSE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,2])
lines(1:p$tSteps,b[[1]]$traps[,1])
plot(1:p$tSteps,a[[1]]$traps[,1],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
lines(1:p$tSteps,b[[1]]$traps[,1])
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,1],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
plot(1:p$tSteps,a[[1]]$traps[,1],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,1])
devtools::document()
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
library(lobsterCatch)
