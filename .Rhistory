coordinatesOverTime[[t]] <- ko[[1]]
trapCatch[[t]] <- ko[[2]]
}
}
outmove = do.call(rbind,coordinatesOverTime)
outmove$T = rep(0:(tSteps-1), each=nrow(tt))
outmove$I = rep(1:nrow(tt), times=tSteps)
outtraps = as.data.frame(do.call(rbind, trapCatch))
outputs$traps = outtraps
outputs$lobsters = outmove
outputs.to.return[[k]] = outputs
print(paste('Timing', Sys.time()-start, 'for iteration #',k,sep=" "))
}
return(outputs.to.return)
})}
#This function also needs to change in order to assign length to lobsters and keep track of trapped lobster's size
SimulateLobsterMovement <- function(p=p,plot=F) {
with(p,{
outputs.to.return = list()
for(k in 1:p$realizations){
start = Sys.time()
outputs = list()
initialGrid = rpoisD(n=ngrids,lambda=initlambda, D = initD)
LobsterStart = data.frame(EASTING = rep(1:ncolgrids,times=nrowgrids), NORTHING = rep(1:nrowgrids,each=ncolgrids), Lobs = initialGrid)
LobsterStart <- subset(LobsterStart,Lobs>0)
if(nrow(LobsterStart)>0) {
replicateCoordinates <- function(d){ rep(d[1:2], d[3]) } #replicates coordinates for grids with more than 1 lobster
tt <- unlist( apply(X = LobsterStart, MARGIN = 1, FUN = replicateCoordinates) )
tt<- matrix(tt, ncol = 2, byrow = TRUE)
colnames(tt)<- c("EASTING","NORTHING")
initialxyCoordinate  = as.data.frame(tt)
initialxyCoordinate$trapped = 0 # this will update as a lobster gets caught and we don't need to update movements
initialxyCoordinate$CL <- NA # Length of lobsters
#uses the distribution of lengths in the csv file and assigns a size bin to each lobster
lobsterSizeFreq <- read.csv(file = 'LobsterSizeFreqs.csv', header = TRUE, stringsAsFactors = FALSE)
lobsterSizeFreq$prob <- lobsterSizeFreq$freq / sum(lobsterSizeFreq$freq )
labels   <- lobsterSizeFreq$bins
lobProb <- lobsterSizeFreq$prob
initialxyCoordinate$CL<-sample(x = labels, size = sum(initialGrid), replace = TRUE, prob = lobProb)
coordinatesOverTime <- list()
coordinatesOverTime[[1]] <- initialxyCoordinate
currentZoI<- currentZoIInit
s =  smult
ntraps = ntrapsstart
trapCoordinates = data.frame(EASTING=trapEastStart,NORTHING=trapNorthStart)
trapCatch = list()
lobSize   = list() #added to store the size of caught lobster
trapCatch[[1]] = rep(0,length=ntraps)
lobSize[[1]]   = rep('',length=ntraps)
outputs$traps = rep(0,times=ntrapsstart)
outputs$lobsters = data.frame(EASTING=0,NORTHING=0,trapped=0,T=0,I=0)
for(t in 2:tSteps){
if(t>2) currentZoI<- currentZoI * smult
ko = updateGridLB( lobsterCoordinates = coordinatesOverTime[[t-1]], trapCoordinates=trapCoordinates, trapCatch=trapCatch[[t-1]], lobSize = lobSize[[t-1]], currentZoI = currentZoI, saturationThreshold=saturationThresholdStart, trapSaturation= trapSaturationStart, how_close=how_closeStart,dstep=dstepstart, lengthBased = lengthBased)
coordinatesOverTime[[t]] <- ko[[1]]
trapCatch[[t]] <- ko[[2]]
lobSize[[t]]   <- ko[[3]]
}
}
outmove = do.call(rbind,coordinatesOverTime)
outmove$T = rep(0:(tSteps-1), each=nrow(tt))
outmove$I = rep(1:nrow(tt), times=tSteps)
outtraps = as.data.frame(do.call(rbind, trapCatch))
outputs$traps = outtraps
outputs$lobsters = outmove
outputs$lobSize = lobSize #Not sure if this is working properly yet
outputs.to.return[[k]] = outputs
print(paste('Timing', Sys.time()-start, 'for iteration #',k,sep=" "))
}
return(outputs.to.return)
})}
#last update : 11 Feb
#updateGridLB is a modified version of updateGrid that keeps track of lobster size
updateGridLB    = function(lobsterCoordinates,trapCoordinates, trapCatch, lobSize, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T, lengthBased = F){
updateGrid    = function(lobsterCoordinates,trapCoordinates, trapCatch, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T){
numberOfLobsters <- nrow(lobsterCoordinates)
if(numberOfLobsters>0){
xNew <- vector(mode = 'numeric', length = numberOfLobsters)
yNew <- vector(mode = 'numeric', length = numberOfLobsters)
trappedLobster<- vector(mode = 'numeric', length = numberOfLobsters)
for( lobsterIndex in 1:numberOfLobsters ){
xOld <- lobsterCoordinates[lobsterIndex,1]
yOld <- lobsterCoordinates[lobsterIndex,2]
trapped <- lobsterCoordinates[lobsterIndex,3]
if(trapped==1){
xNew[lobsterIndex] = xOld
yNew[lobsterIndex] = yOld
trappedLobster[lobsterIndex] = trapped
next()
}
distanceToTrap = distanceClosestTrap(lob_loc = c(xOld,yOld), trap_loc = trapCoordinates[,c(1,2)] )
if( distanceToTrap[1] > radius_of_influence){
temp <- randomMove(xLobster = xOld , yLobster = yOld , dStep = dstep)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedLobster[lobsterIndex] = 0
}else{
temp <- directionalMove(xLobster = xOld , yLobster = yOld , distanceToTrap = distanceToTrap[1], radius_of_influence = radius_of_influence, dStep = dstep, ZoI = currentZoI)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedQ = trapInPath(loc1 = c(xOld,yOld), loc2 = c(xNew[lobsterIndex],yNew[lobsterIndex]), trap_loc = trapCoordinates[distanceToTrap[2],],how_close=how_close)
if(trappedQ[3]==1) {
if(trapSaturation) pC = catchability(q0= q0,qmin=qmin, saturationThreshold=saturationThreshold, Ct=trapCatch[distanceToTrap[2]] )
if(!trapSaturation) pC = q0
caught = rbinom(n=1,size=1,prob=pC)
if(caught==1){
trapCatch[distanceToTrap[2]] =trapCatch[distanceToTrap[2]]+1
xNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],1]
yNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],2]
trappedLobster[lobsterIndex] = 1
}
}
}
}
updatedGrid <- data.frame(EASTING = xNew, NORTHING = yNew, trapped = trappedLobster)
return(list(updatedGrid, trapCatch))
}
}
updateGrid    = function(lobsterCoordinates,trapCoordinates, trapCatch, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T){
numberOfLobsters <- nrow(lobsterCoordinates)
if(numberOfLobsters>0){
xNew <- vector(mode = 'numeric', length = numberOfLobsters)
yNew <- vector(mode = 'numeric', length = numberOfLobsters)
trappedLobster<- vector(mode = 'numeric', length = numberOfLobsters)
for( lobsterIndex in 1:numberOfLobsters ){
xOld <- lobsterCoordinates[lobsterIndex,1]
yOld <- lobsterCoordinates[lobsterIndex,2]
trapped <- lobsterCoordinates[lobsterIndex,3]
if(trapped==1){
xNew[lobsterIndex] = xOld
yNew[lobsterIndex] = yOld
trappedLobster[lobsterIndex] = trapped
next()
}
distanceToTrap = distanceClosestTrap(lob_loc = c(xOld,yOld), trap_loc = trapCoordinates[,c(1,2)] )
if( distanceToTrap[1] > radius_of_influence){
temp <- randomMove(xLobster = xOld , yLobster = yOld , dStep = dstep)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedLobster[lobsterIndex] = 0
}else{
temp <- directionalMove(xLobster = xOld , yLobster = yOld , distanceToTrap = distanceToTrap[1], radius_of_influence = radius_of_influence, dStep = dstep, ZoI = currentZoI)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedQ = trapInPath(loc1 = c(xOld,yOld), loc2 = c(xNew[lobsterIndex],yNew[lobsterIndex]), trap_loc = trapCoordinates[distanceToTrap[2],],how_close=how_close)
if(trappedQ[3]==1) {
if(trapSaturation) pC = catchability(q0= q0,qmin=qmin, saturationThreshold=saturationThreshold, Ct=trapCatch[distanceToTrap[2]] )
if(!trapSaturation) pC = q0
caught = rbinom(n=1,size=1,prob=pC)
if(caught==1){
trapCatch[distanceToTrap[2]] =trapCatch[distanceToTrap[2]]+1
xNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],1]
yNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],2]
trappedLobster[lobsterIndex] = 1
}
}
}
}
updatedGrid <- data.frame(EASTING = xNew, NORTHING = yNew, trapped = trappedLobster)
return(list(updatedGrid, trapCatch))
}
}
updateGrid    = function(lobsterCoordinates,trapCoordinates, trapCatch, radius_of_influence=15, dstep = 5, currentZoI, how_close=0.1, q0=.5, qmin=0, saturationThreshold=5, trapSaturation=T){
numberOfLobsters <- nrow(lobsterCoordinates)
if(numberOfLobsters>0){
xNew <- vector(mode = 'numeric', length = numberOfLobsters)
yNew <- vector(mode = 'numeric', length = numberOfLobsters)
trappedLobster<- vector(mode = 'numeric', length = numberOfLobsters)
for( lobsterIndex in 1:numberOfLobsters ){
xOld <- lobsterCoordinates[lobsterIndex,1]
yOld <- lobsterCoordinates[lobsterIndex,2]
trapped <- lobsterCoordinates[lobsterIndex,3]
if(trapped==1){
xNew[lobsterIndex] = xOld
yNew[lobsterIndex] = yOld
trappedLobster[lobsterIndex] = trapped
next()
}
distanceToTrap = distanceClosestTrap(lob_loc = c(xOld,yOld), trap_loc = trapCoordinates[,c(1,2)] )
if( distanceToTrap[1] > radius_of_influence){
temp <- randomMove(xLobster = xOld , yLobster = yOld , dStep = dstep)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedLobster[lobsterIndex] = 0
}else{
temp <- directionalMove(xLobster = xOld , yLobster = yOld , distanceToTrap = distanceToTrap[1], radius_of_influence = radius_of_influence, dStep = dstep, ZoI = currentZoI)
xNew[lobsterIndex] <- temp$EASTING
yNew[lobsterIndex] <- temp$NORTHING
trappedQ = trapInPath(loc1 = c(xOld,yOld), loc2 = c(xNew[lobsterIndex],yNew[lobsterIndex]), trap_loc = trapCoordinates[distanceToTrap[2],],how_close=how_close)
if(trappedQ[3]==1) {
if(trapSaturation) pC = catchability(q0= q0,qmin=qmin, saturationThreshold=saturationThreshold, Ct=trapCatch[distanceToTrap[2]] )
if(!trapSaturation) pC = q0
caught = rbinom(n=1,size=1,prob=pC)
if(caught==1){
trapCatch[distanceToTrap[2]] =trapCatch[distanceToTrap[2]]+1
xNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],1]
yNew[lobsterIndex] <- trapCoordinates[distanceToTrap[2],2]
trappedLobster[lobsterIndex] = 1
}
}
}
}
updatedGrid <- data.frame(EASTING = xNew, NORTHING = yNew, trapped = trappedLobster)
return(list(updatedGrid, trapCatch))
}
}
devtools::document()
getwd(
)
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
library(lobsterCatch)
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$realizations=5 #number of iterations/simulations
p$tSteps=10  #timesteps per iteration
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
#run the model
a = SimulateLobsterMovement(p=p)
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
library(lobsterCatch)
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$realizations=5 #number of iterations/simulations
p$tSteps=10  #timesteps per iteration
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='N Caught')
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='N Caught', ylim=(o,10))
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='N Caught', ylim=(0,10))
a[[1]]
View(a)
plot(1:p$realizations,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
plot(1:p$realizations,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
#lets change a parameter
p$saturationThresholdStart=10
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$niter,b$traps[,1])
lines(1:p$tSteps,b$traps[,1])
lines(1:p$tSteps,b$[[1]]$traps[,3])
lines(1:p$tSteps,b[[1]]$traps[,3])
#lets change a parameter
p$saturationThresholdStart=10
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,3])
#lets change a parameter
p$saturationThresholdStart=20
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,3])
b[[1]]
b[[1]]$traps[,3]
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
lines(1:p$tSteps,b[[1]]$traps[,3])
#run the model
a = SimulateLobsterMovement(p=p)
p$realizations=10 #number of iterations/simulations
p$tSteps=50  #timesteps per iteration
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught')
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught')
#lets change a parameter
p$saturationThresholdStart=20
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,2])
?plot
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught',ylim = c(o,10))
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
lines(1:p$tSteps,b[[1]]$traps[,2])
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,2])
lines(1:p$tSteps,b[[1]]$traps[,3])
b
p$lengthBased= FALSE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,2])
lines(1:p$tSteps,b[[1]]$traps[,1])
plot(1:p$tSteps,a[[1]]$traps[,1],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
lines(1:p$tSteps,b[[1]]$traps[,1])
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,1],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
plot(1:p$tSteps,a[[1]]$traps[,1],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,1])
devtools::document()
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
library(lobsterCatch)
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main')
# In order to load the latest version of the package:
devtools::install_github('vpourfaraj/lobsterCatch',ref='main', force = TRUE)
library(lobsterCatch)
#initialize a parameter file to pass info into the code and then put all into a function
p = list()
p$nrowgrids = 10
p$ncolgrids = 10
p$ngrids=p$nrowgrids * p$ncolgrids
p$initlambda=.1
p$initD = 3
p$smult = 0.993
p$currentZoIInit = 1
p$trapSaturationStart = T
p$trapEastStart = c(5,3,4)
p$trapNorthStart = c(5,3,4)
p$ntrapsstart = length(p$trapEastStart)
p$saturationThresholdStart = 5
p$how_closeStart = 1
p$dstepstart = 5
p$realizations=10 #number of iterations/simulations
p$tSteps=50  #timesteps per iteration
p$lengthBased= TRUE
#run the model
a = SimulateLobsterMovement(p=p)
#Once the package is installed, data in extdata folder can be accessed using this code:
system.file("extdata", "LobsterSizeFreqs.csv", package = "lobsterCatch")
#run the model
a = SimulateLobsterMovement(p=p)
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,1],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,1])
plot(1:p$tSteps,a[[1]]$traps[,2],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
lines(1:p$tSteps,b[[1]]$traps[,2])
lines(1:p$tSteps,b[[1]]$traps[,3])
p$initlambda=.5
#run the model
a = SimulateLobsterMovement(p=p)
#run the model
a = SimulateLobsterMovement(p=p)
plot(1:p$tSteps,a[[1]]$traps[,3],xlab='Time',ylab='Number of lobsters Caught',ylim = c(0,10))
#lets change a parameter
p$saturationThresholdStart=30
# rerun
b = SimulateLobsterMovement(p=p)
lines(1:p$tSteps,b[[1]]$traps[,3])
#or just run it a bunch of times since the model is stochastic
p$saturationThresholdStart = 5
time.to.max=list()
max.catch = list()
realizations = 50
plot(1:p$niter,xlab='Time',ylab='N Caught',ylim=c(0,15),type='n')
#or just run it a bunch of times since the model is stochastic
p$saturationThresholdStart = 5
time.to.max=list()
max.catch = list()
realizations = 50
niter =20
plot(1:p$niter,xlab='Time',ylab='N Caught',ylim=c(0,15),type='n')
p$nite =20
plot(1:p$niter,xlab='Time',ylab='N Caught',ylim=c(0,15),type='n')
p$niter =20
plot(1:p$niter,xlab='Time',ylab='N Caught',ylim=c(0,15),type='n')
for(i in 1:realizations){
a = SimulateLobsterMovement(p=p)
for(j in 1:ncol(a$traps)){
lines(1:p$niter,a$traps[,j])
}
time.to.max[[i]] = apply(a$traps,2, which.max)
max.catch[[i]] = apply(a$traps,2,max)
}
time.to.max = do.call(rbind,time.to.max)
max.catch = do.call(rbind,max.catch)
#calculating dispersion
disp = apply(max.catch,1,dispersion)
mean(disp)
time.to.max = do.call(rbind,time.to.max)
max.catch = do.call(rbind,max.catch)
time.to.max = do.call(rbind,time.to.max)
time.to.max
time.to.max
a$traps,2
time.to.max[[i]] = apply(a[[1]]$traps,2, which.max)
time.to.max
max.catch[[i]] = apply(a[[1]]$traps,2,max)
for(i in 1:realizations){
a = SimulateLobsterMovement(p=p)
for(j in 1:ncol(a$traps)){
lines(1:p$niter,a$traps[,j])
}
time.to.max[[i]] = apply(a[[1]]$traps,2, which.max)
max.catch[[i]] = apply(a[[1]]$traps,2,max)
}
time.to.max = do.call(rbind,time.to.max)
max.catch = do.call(rbind,max.catch)
#calculating dispersion
disp = apply(max.catch,1,dispersion)
mean(disp)
a
dispersion
max.catch
disp
mean(disp)
#next trial changing saturation
p$saturationThresholdStart = 8
time.to.max8=c()
max.catch8 = c()
time.to.max8=list()
max.catch8 = list()
realizations = 50
plot(1:p$niter,xlab='Time',ylab='N Caught',ylim=c(0,15),type='n')
for(i in 1:realizations){
a = SimulateLobsterMovement(p=p)
for(j in 1:ncol(a$traps)){
lines(1:p$niter,a$traps[,j])
}
time.to.max8[[i]] = apply(a$traps,2, which.max)
max.catch8[[i]] = apply(a$traps,2,max)
}
time.to.max8
max.catch8
time.to.max8[[i]] = apply(a[[1]]$traps,2, which.max)
max.catch8[[i]] = apply(a[[1]]$traps,2,max)
max.catch8
#next trial changing saturation
p$saturationThresholdStart = 8
time.to.max8=c()
max.catch8 = c()
time.to.max8=list()
max.catch8 = list()
realizations = 50
plot(1:p$niter,xlab='Time',ylab='N Caught',ylim=c(0,15),type='n')
for(i in 1:realizations){
a = SimulateLobsterMovement(p=p)
for(j in 1:ncol(a$traps)){
lines(1:p$niter,a$traps[,j])
}
time.to.max8[[i]] = apply(a[[1]]$traps,2, which.max)
max.catch8[[i]] = apply(a[[1]]$traps,2,max)
}
niter
realizations
#next trial changing saturation
p$saturationThresholdStart = 8
time.to.max8=c()
max.catch8 = c()
time.to.max8=list()
max.catch8 = list()
realizations
realizations = 10
plot(1:p$niter,xlab='Time',ylab='N Caught',ylim=c(0,15),type='n')
niter
for(i in 1:realizations){
a = SimulateLobsterMovement(p=p)
for(j in 1:ncol(a[[1]]$traps)){
lines(1:p$niter,a[[1]]$traps[,j])
}
time.to.max8[[i]] = apply(a[[1]]$traps,2, which.max)
max.catch8[[i]] = apply(a[[1]]$traps,2,max)
}
max.catch8
a
library(roxygen2)
devtools::document()
